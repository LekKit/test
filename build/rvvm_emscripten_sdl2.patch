diff --git a/Makefile b/Makefile
index f6ebb38..56e6063 100644
--- a/Makefile
+++ b/Makefile
@@ -126,10 +126,10 @@ else
 # Emscripten-specific build options
 ifeq ($(OS),emscripten)
 override CFLAGS += -pthread
-override LDFLAGS += -s TOTAL_MEMORY=512MB -s PROXY_TO_PTHREAD
+override LDFLAGS += -s TOTAL_MEMORY=512MB
 BIN_EXT := .html
 LIB_EXT := .so
-USE_SDL ?= 1
+USE_SDL ?= 2
 USE_NET ?= 0
 else
 
diff --git a/src/devices/sdl_window.c b/src/devices/sdl_window.c
index dffb596..092c301 100644
--- a/src/devices/sdl_window.c
+++ b/src/devices/sdl_window.c
@@ -635,9 +635,11 @@ bool sdl_window_init(gui_window_t* win)
         if (SDL_MUSTLOCK(sdl_surface)) {
             rvvm_info("SDL surface is locking. Expect higher CPU use.");
             win->fb.buffer = vma_alloc(NULL, framebuffer_size(&win->fb), VMA_RDWR);
+#ifndef __EMSCRIPTEN__
         } else if (((size_t)sdl_surface->pixels) & 0xFFF) {
             rvvm_info("SDL surface is misaligned. Expect higher CPU use.");
             win->fb.buffer = vma_alloc(NULL, framebuffer_size(&win->fb), VMA_RDWR);
+#endif
         } else {
             // Direct page-aligned framebuffer surface, like XShm
             win->fb.buffer = sdl_surface->pixels;
diff --git a/src/main.c b/src/main.c
index 051dee5..4f3a886 100644
--- a/src/main.c
+++ b/src/main.c
@@ -200,6 +200,12 @@ static bool rvvm_cli_configure(rvvm_machine_t* machine, int argc, const char** a
     return true;
 }
 
+
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+void rvvm_eventloop_tick(void);
+#endif
+
 static int rvvm_cli_main(int argc, const char** argv)
 {
     const char* arg_name = "";
@@ -264,6 +270,10 @@ static int rvvm_cli_main(int argc, const char** argv)
     if (rvvm_cli_configure(machine, argc, argv, bootrom, tap)) {
         rvvm_start_machine(machine);
 
+#ifdef __EMSCRIPTEN__
+        emscripten_set_main_loop(rvvm_eventloop_tick, 30, true);
+        return 0;
+#else
         if (!rvvm_has_arg("noisolation")) {
             // Preparations are done, isolate the process as much as possible
             rvvm_restrict_process();
@@ -271,6 +281,7 @@ static int rvvm_cli_main(int argc, const char** argv)
 
         // Returns on machine shutdown
         rvvm_run_eventloop();
+#endif
     } else {
         rvvm_error("Failed to initialize VM");
     }
diff --git a/src/rvvm.c b/src/rvvm.c
index 71f1dbf..5a26489 100644
--- a/src/rvvm.c
+++ b/src/rvvm.c
@@ -221,71 +221,58 @@ static void rvvm_reset_machine_state(rvvm_machine_t* machine)
     }
 }
 
-static void* rvvm_eventloop(void* manual)
+void rvvm_eventloop_tick(void)
 {
-    if (!manual && rvvm_getarg_int("noisolation") < 1) {
-        rvvm_restrict_this_thread();
-    }
-    /*
-     * The eventloop runs in a separate thread if needed,
-     * and returns on any machine shutdown if ran manually.
-     */
-    while (true) {
-        spin_lock(&global_lock);
-        if (vector_size(global_machines) == 0 || global_manual == !manual) {
-            spin_unlock(&global_lock);
-            break;
-        }
-
-        vector_foreach_back(global_machines, m) {
-            rvvm_machine_t* machine = vector_at(global_machines, m);
-            uint32_t power_state = atomic_load_uint32(&machine->power_state);
+    spin_lock(&global_lock);
 
-            if (power_state == RVVM_POWER_ON) {
-                vector_foreach(machine->harts, i) {
-                    rvvm_hart_t* vm = vector_at(machine->harts, i);
-                    // Сheck hart timer interrupts
-                    riscv_hart_check_timer(vector_at(machine->harts, i));
-                    if (rvvm_get_opt(machine, RVVM_OPT_MAX_CPU_CENT) < 100) {
-                        uint32_t preempt = 10 - ((10 * rvvm_get_opt(machine, RVVM_OPT_MAX_CPU_CENT) + 9) / 100);
-                        riscv_hart_preempt(vm, preempt);
-                    }
+    vector_foreach_back(global_machines, m) {
+        rvvm_machine_t* machine = vector_at(global_machines, m);
+        uint32_t power_state = atomic_load_uint32(&machine->power_state);
+
+        if (power_state == RVVM_POWER_ON) {
+            vector_foreach(machine->harts, i) {
+                rvvm_hart_t* vm = vector_at(machine->harts, i);
+                // Сheck hart timer interrupts
+                riscv_hart_check_timer(vector_at(machine->harts, i));
+                if (rvvm_get_opt(machine, RVVM_OPT_MAX_CPU_CENT) < 100) {
+                    uint32_t preempt = 10 - ((10 * rvvm_get_opt(machine, RVVM_OPT_MAX_CPU_CENT) + 9) / 100);
+                    riscv_hart_preempt(vm, preempt);
                 }
+            }
 
-                vector_foreach(machine->mmio_devs, i) {
-                    rvvm_mmio_dev_t* dev = vector_at(machine->mmio_devs, i);
-                    if (dev->type && dev->type->update) {
-                        // Update device
-                        dev->type->update(dev);
-                    }
+            vector_foreach(machine->mmio_devs, i) {
+                rvvm_mmio_dev_t* dev = vector_at(machine->mmio_devs, i);
+                if (dev->type && dev->type->update) {
+                    // Update device
+                    dev->type->update(dev);
                 }
-            } else {
-                // The machine was shut down or reset
+            }
+        } else {
+            // The machine was shut down or reset
+            vector_foreach(machine->harts, i) {
+                riscv_hart_pause(vector_at(machine->harts, i));
+            }
+            // Call reset/poweroff handler
+            if (power_state == RVVM_POWER_RESET) {
+                rvvm_info("Machine %p resetting", machine);
+                rvvm_reset_machine_state(machine);
                 vector_foreach(machine->harts, i) {
-                    riscv_hart_pause(vector_at(machine->harts, i));
-                }
-                // Call reset/poweroff handler
-                if (power_state == RVVM_POWER_RESET) {
-                    rvvm_info("Machine %p resetting", machine);
-                    rvvm_reset_machine_state(machine);
-                    vector_foreach(machine->harts, i) {
-                        riscv_hart_spawn(vector_at(machine->harts, i));
-                    }
-                } else {
-                    rvvm_info("Machine %p shutting down", machine);
-                    atomic_store_uint32(&machine->running, false);
-                    vector_erase(global_machines, m);
-                    if (manual) {
-                        spin_unlock(&global_lock);
-                        return NULL;
-                    }
+                    riscv_hart_spawn(vector_at(machine->harts, i));
                 }
+            } else {
+                rvvm_info("Machine %p shutting down", machine);
+                atomic_store_uint32(&machine->running, false);
+                vector_erase(global_machines, m);
             }
         }
-        spin_unlock(&global_lock);
-        condvar_wait(eventloop_cond, 16);
     }
 
+    spin_unlock(&global_lock);
+}
+
+static void* rvvm_eventloop(void* manual)
+{
+
     return NULL;
 }
 
diff --git a/src/utils.c b/src/utils.c
index 682afef..e958ebc 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -100,7 +100,11 @@ static void log_print(const char* prefix, const char* fmt, va_list args)
         if (tmp > 0) pos += EVAL_MIN(vsp_size - 1, (size_t)tmp);
     }
     rvvm_strlcpy(buffer + pos, log_has_colors() ? "\033[0m\n" : "\n", sizeof(buffer) - pos);
+#ifdef __EMSCRIPTEN__
+    puts(buffer);
+#else
     fputs(buffer, stderr);
+#endif
 }
 
 PRINT_FORMAT void rvvm_info(const char* str, ...)
